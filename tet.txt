import csv
import re
from datetime import datetime
import chardet
import textwrap

def detect_encoding(file_path):
    with open(file_path, "rb") as f:
        raw = f.read(10000)
        result = chardet.detect(raw)
        return result["encoding"]

def validate_pli_record(fields, recno):
    errors = []

    if len(fields) != 16:
        errors.append(f"[rekord {recno}] niew≈Ça≈õciwa liczba p√≥l: {len(fields)} (oczekiwano 16)")
        return errors

    # 1. Kod zlecenia
    if not re.fullmatch(r'110|210|71', fields[0]):
        errors.append(f"[rekord {recno}, pole 1] niepoprawny kod zlecenia: {fields[0]}")

    # 2. Data wykonania
    try:
        datetime.strptime(fields[1], "%Y%m%d")
    except ValueError:
        errors.append(f"[rekord {recno}, pole 2] niepoprawna data wykonania: {fields[1]}")

    # 3. Kwota
    if not re.fullmatch(r'\d{1,15}', fields[2]):
        errors.append(f"[rekord {recno}, pole 3] niepoprawna kwota: {fields[2]}")

    # 4. Numer rozliczeniowy banku zleceniodawcy
    if not re.fullmatch(r'\d{8}', fields[3]):
        errors.append(f"[rekord {recno}, pole 4] niepoprawny BSC zleceniodawcy: {fields[3]}")

    # 5. Pole zerowe
    if fields[4] != '0':
        errors.append(f"[rekord {recno}, pole 5] powinno byƒá '0', a jest: {fields[4]}")

    # 6. Numer rachunku zleceniodawcy NRB
    if not re.fullmatch(r'\d{26}', fields[5]):
        errors.append(f"[rekord {recno}, pole 6] niepoprawny NRB zleceniodawcy: {fields[5]}")

    # 7. Numer rachunku kontrahenta NRB
    if not re.fullmatch(r'\d{26}', fields[6]):
        errors.append(f"[rekord {recno}, pole 7] niepoprawny NRB kontrahenta: {fields[6]}")

    # 8, 9, 12 ‚Äì nazwy/adresy/tytu≈Çy (maks. 4 linie po 35 znak√≥w)
    for idx in [7, 8, 11]:
        content = fields[idx]
        lines = content.split('|')
        if len(lines) > 4:
            errors.append(f"[rekord {recno}, pole {idx+1}] za du≈ºo linii (max 4): {lines}")
        for lno, line_content in enumerate(lines, 1):
            if len(line_content) > 35:
                errors.append(
                    f"[rekord {recno}, pole {idx+1}, linia {lno}] za d≈Çuga (>35 znak√≥w): '{line_content}'"
                )

    # 10. Pole zerowe
    if fields[9] != '0':
        errors.append(f"[rekord {recno}, pole 10] powinno byƒá '0', a jest: {fields[9]}")

    # 11. Numer rozliczeniowy banku kontrahenta
    if not re.fullmatch(r'\d{8}', fields[10]):
        errors.append(f"[rekord {recno}, pole 11] niepoprawny BSC kontrahenta: {fields[10]}")

    # 15. Klasyfikacja polecenia
    valid_klasyfikacja = {"110": "51", "210": "01", "71": "71"}
    if fields[14] != valid_klasyfikacja.get(fields[0], ""):
        errors.append(f"[rekord {recno}, pole 15] niew≈Ça≈õciwa klasyfikacja {fields[14]} dla kodu {fields[0]}")

    return errors

def main(file_path):
    encoding = detect_encoding(file_path)
    print(f"üìë Strona kodowa pliku: {encoding}\n")

    with open(file_path, "r", encoding=encoding, errors="replace", newline="") as f:
        reader = csv.reader(f, delimiter=",", quotechar='"')
        all_fields = []
        for row in reader:
            all_fields.extend(row)

    # czy liczba p√≥l dzieli siƒô na 16?
    if len(all_fields) % 16 != 0:
        print(f"‚ùå UWAGA: ca≈Çkowita liczba p√≥l = {len(all_fields)}, nie dzieli siƒô przez 16!")
        # poka≈º podejrzany fragment ostatnich p√≥l
        tail = all_fields[-20:]
        print("Ostatnie pola:", tail)

    # Walidacja rekord√≥w
    for recno, start in enumerate(range(0, len(all_fields), 16), 1):
        record = all_fields[start:start+16]
        errs = validate_pli_record(record, recno)
        if errs:
            print("\n‚ùå B≈Çƒôdy:")
            for e in errs:
                print("  -", e)
            print("  ‚û° Surowe pola rekordu:", record)
        else:
            print(f"‚úÖ Rekord {recno} poprawny")

if __name__ == "__main__":
    main("przyklad.pli")
