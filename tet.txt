#!/bin/bash

MAPA="plik.map"
KATALOG="./dane"
BAZA="test"
SQLTMP="zaladuj_tmp.sql"
DEPENDENCJE="zaleznosci.tmp"
WSZYSTKIE_TABELKI="tabelki.tmp"
KOLEJNOSC="kolejnosc.tmp"

# 1. Pobierz zależności do pliku
dbaccess "$BAZA" <<EOF > "$DEPENDENCJE"
UNLOAD TO stdout DELIMITER '|'
SELECT c.tabname, p.tabname
FROM systables c
JOIN sysconstraints cc ON cc.tabid = c.tabid
JOIN sysreferences r ON r.constrid = cc.constrid
JOIN sysconstraints pc ON pc.constrid = r.primary
JOIN systables p ON p.tabid = pc.tabid
WHERE cc.constrtype = 'R';
EOF

# 2. Wyciągnij wszystkie tabele z pliku.map
awk -F'|' '{print $2}' "$MAPA" | sort -u > "$WSZYSTKIE_TABELKI"

# 3. Sortowanie zależności w Bashu — topologicznie
# Działa tylko jeśli nie ma cykli!

# Stwórz graf zależności (parent -> children)
declare -A CHILDREN
declare -A PARENTS
declare -A VISITED

# Załaduj zależności
while IFS='|' read -r child parent; do
  CHILDREN["$parent"]+="$child "
  PARENTS["$child"]+="$parent "
done < "$DEPENDENCJE"

# Funkcja rekurencyjna DFS
visit() {
  local tabela="$1"
  [[ "${VISITED[$tabela]}" == 1 ]] && return
  VISITED["$tabela"]=1
  for child in ${CHILDREN["$tabela"]}; do
    visit "$child"
  done
  echo "$tabela" >> "$KOLEJNOSC"
}

# Rozpocznij od tabel, które nie mają parentów
> "$KOLEJNOSC"
for tabela in $(cat "$WSZYSTKIE_TABELKI"); do
  if [[ -z "${PARENTS[$tabela]}" ]]; then
    visit "$tabela"
  fi
done

# 4. Generuj plik SQL
> "$SQLTMP"

# TRUNCATE w odwrotnej kolejności
tac "$KOLEJNOSC" | while read tabela; do
  echo "TRUNCATE TABLE $tabela;" >> "$SQLTMP"
done

# LOAD w poprawnej kolejności
while read tabela; do
  grep -F "|$tabela" "$MAPA" | while IFS='|' read -r plik tab; do
    echo "LOAD FROM '$KATALOG/$plik' DELIMITER '|' INSERT INTO $tab;" >> "$SQLTMP"
  done
done < "$KOLEJNOSC"

# 5. Wykonaj w dbaccess
echo "Wykonuję TRUNCATE i LOAD wg zależności (bez Pythona)..."
dbaccess "$BAZA" "$SQLTMP"
